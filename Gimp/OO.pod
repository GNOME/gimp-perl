=head1 NAME

Gimp::OO - Pseudo-OO for Gimp functions.

=head1 SYNOPSIS

  use Gimp;		# Gimp::OO is now part of Gimp.

=head1 DESCRIPTION

As you might have noticed, you can sort most gimp functions fall into three
groups, depending on the name-prefix: C<gimp_>, C<plug_in_>, C<extension_>
etc..

Whats more, there are functions groups like C<gimp_image_> or
C<gimp_selection_>, operating on a common object, B<Images> and B<Selection>
in this case.

If you only had the plain syntax, your scripts would quickly aquire
the "vertical gimp syndrome":

 gimp_palette_set_foreground(...)
 gimp_layer_new(...)
 gimp_palette_set_background(...)
 gimp_image_add_layer(...)

etc. Of course, your fingers will suffer from severe injuries as well.

A solution to this situation is to use OO-syntax. Gimp plays some (very)
dirty tricks and provides a number of classes, like C<Gimp::Image> and
C<Gimp::Palette> that allow shorter identifiers to be used.

If you call a method, C<Gimp> tries to find a gimp function by
prepending a number of prefixes until it finds a valid function:

 $image = Gimp->image_new(...); # calls gimp_image_new(...)
 $image = Gimp::Image->new(...);	# calls gimp_image_new as well
 $image = new Gimp::Image(...);	# the same in green
 Gimp::Palette->set_foreground(...)	# calls gimp_palette_set_foreground(..)

Return values from functions are automatically blessed (through
The Magic Autobless feature ;) to their corresponding classes, i.e.

 $image = new Gimp::Image(...);	# $image is now blessed to Gimp::Image
 $image->height;		# calls gimp_image_height($image)
 $image->flatten;		# likewise gimp_flatten($image)
 $image->histogram(...);	# calls gimp_histogram($image,...), since
				# gimp_image_histogram does not exist

The object argument (C<$image> in the above examples) is prepended to the
argument list - this is how Perl does OO.

Another shortcut: many functions want a (redundant) image argument, like

 $image->shear ($layer, ...)

Since all you want is to shear the C<$layer>, not the C<$image>, this is
confusing as well. In cases like this, Gimp allows you to write:

 $layer->shear (...)

And automatically infers the additional IMAGE-type argument.

As the (currently) last goodie, if the first argument is of type INT32, its
name is "run_mode" and there are no other ambiguties, you can omit it, i.e.
these three calls are equivalent:

 plug_in_gauss_rle (RUN_NONINTERACTIVE, $image, $layer, 8, 1, 1);
 plug_in_gauss_rle ($image, $layer, 8, 1, 1);
 plug_in_gauss_rle ($layer, 8, 1, 1);

You can call all sorts of sensible and not-so-sensible functions,
so this feature can be abused:

 patterns_list Gimp::Image;	# will call gimp_patterns_list
 quit Gimp::Plugin;		# will quit the Gimp, not an Plugin.

there is no image involved here whatsoever...

=head1 AVAILABLE CLASSES

The following classes are available. The prefixes that are checked are
shown as well (the null prefix "" is implicit).

=over 4

=item Gimp (there is no Gimp::Gimp, only Gimp::)

 gimp_

=item Gimp::Layer

 gimp_layer_
 gimp_drawable_
 gimp_floating_sel_
 gimp_image_
 gimp_
 plug_in_
 perl_fu_

=item Gimp::Image

 gimp_image_
 gimp_drawable_
 gimp_
 plug_in_
 perl_fu_

=item Gimp::Drawable

 gimp_drawable_
 gimp_layer_
 gimp_image_
 gimp_
 plug_in_
 perl_fu_

=item Gimp::Selection

 gimp_selection_

=item Gimp::Channel

 gimp_channel_
 gimp_drawable_
 gimp_selection_
 gimp_image_
 gimp_
 plug_in_
 perl_fu_

=item Gimp::Display

 gimp_display_
 gimp_

=item Gimp::Palette

 gimp_palette_

=item Gimp::Plugin

 plug_in_
 perl_fu_

=item Gimp::Gradients

 gimp_gradients_

=item Gimp::Edit

 gimp_edit_

=item Gimp::Progress

 gimp_progress_

=item Gimp::Region

(none except the implicit null prefix)

=item Gimp::Tile

 gimp_tile_

=item Gimp::PixelRgn

 gimp_pixel_rgn_

=item Gimp::GimpDrawable

 gimp_gdrawable_

=item Gimp::Brushes

 gimp_brushes_

=item Gimp::Patterns

 gimp_patterns_

=back

=head1 AUTHOR

Marc Lehmann <pcg@goof.com>

=head1 SEE ALSO

perl(1), L<Gimp>.

