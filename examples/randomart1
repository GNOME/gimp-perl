#!/usr/bin/perl

eval 'exec /usr/bin/perl  -S $0 ${1+"$@"}'
    if 0; # not running under some shell

# <sjburges@gimp.org> 12/13/03: adjusted number of blend arguments to 
#                               be 1.3.23 compatible 
#                               Removed channel_ops_ from channel_ops_offset    #                               Adjusted colors to be 1.3.x compatible

use Gimp;
use Gimp::Fu;

# Definiere die Konstante "pi mal zwei"
use constant PIx2 => 8 * atan2 1,1;

register "random_art_1",			# Funktionsname
         "Create a Random Tile",		# Kurzhilfe
         "Create a tileable image by repeatedly drawing colourful polygons",
         					# Hilfetext
         "Marc Lehmann",			# Autor
         "Marc Lehmann <pcg\@goof.com",		# Copyright
         "0.4", 				# Version/Datum
         N_"<Image>/Filters/Render/Random Art #1...",	# Menüpfad
         "",					# Bildtypen
         # Eingabeparameter
         # Typ		Name		Beschreibung		Wert
         [
          [PF_INT32,	'width',	'Image Width',	 	300],
          [PF_INT32,	'height',	'Image Height',	 	300],
          [PF_SLIDER,	'num_poly',	'Number of Polygons', 	20, [5,100,1]],
          [PF_SLIDER,	'edges',	'Number of Edges',      10, [3, 30, 1]],
          [PF_SLIDER,	'revolutions',	'Number of Revolutions',1, [1, 3, 1]],
          [PF_SLIDER,	'feather',	'Feather Radius',	30, [1, 100]],
          [PF_BOOL,	'supersample',	'Adaptive Supersampling?', 0],
         ],
         [PF_IMAGE],
         sub {					# Perl-Code
   # Die Parameter werden ganz "normal" übergeben:
   my ($w,$h,$num_poly,$edges,$revolutions,$feather,$super)=@_;
   Context->push();

   # Erzeuge ein neues Bild
   my $image = new Gimp::Image($w,$h,RGB);
   $image->undo_disable;

   # Erzeuge die erste Ebene für das Bild
   my $layer = $image->layer_new($w,$h,RGB_IMAGE,
                   "Random Art #1",100,NORMAL_MODE);

   # Füge sie in das Bild ein
   $image->add_layer($layer,0);

   # Setze die Hintergrundfarben
   Context->set_background('white');

   # ...und lösche die Ebene damit
   $layer->fill(BACKGROUND_FILL);

   # Jetzt wurde ein neues, leeres Bild erzeugt, und
   # das Zeichnen kann beginnen.

   # Erzeuge zufällige Polygone, fülle sie mit einem
   # zufälligen Farbgradienten und verschiebe das Bild
   # wiederholt.
   for (1..$num_poly) {
      my @ecken;
      for (1..$edges*$revolutions) {
         my $r = rand(0.4)+0.1;
         push(@ecken, $w/2+sin($_*PIx2/$edges)*$r*$w,
                      $h/2+cos($_*PIx2/$edges)*$r*$h);
      }

      # Selektiere die Region
      $image->free_select (\@ecken, CHANNEL_OP_REPLACE, 1, 1, $feather);

      # Wähle zufällig zwei Farben aus
      Context->set_foreground([rand(256)/256.0,rand(256)/256.0,rand(256)/256.0]);
      Context->set_background([rand(256)/256.0,rand(256)/256.0,rand(256)/256.0]);
      
      # Und erzeuge einen Farbverlauf über das Bild
      $layer->edit_blend (FG_BG_HSV_MODE,      
                     DIFFERENCE_MODE, 
		     GRADIENT_LINEAR,         # gradient type
		     100,                     # opacity
                     0,                       # offset
		     REPEAT_TRIANGULAR,       # repeat
		     0,                       # reverse
		     $super,                  # supersampling
		     2,                       
		     3, 
		     0,                       # no dithering
                     $w/2,                    # x1
		     $h/2,                    # y1
                     rand($w),                # x2
		     rand($h));               # y2
      
      # Und dann verschiebe das Bild etwas
      $layer->offset (1,0,(rand(0.8)+0.1)*$w,(rand(0.8)+0.1)*$h);
   }

   Context->pop();

   $image->selection_none;
   $image->undo_enable;

   # Gib das neu erzeugte Bild zurück, damit es angezeigt wird.
   $image;
};

exit main;

=head1 LICENSE

Copyright Marc Lehman.
Distributed under the same terms as Gimp-Perl.

=cut
