#!/usr/bin/perl

use Gimp qw(:auto __ N_);
use Gimp::Fu;
use Gimp::Util;
#Gimp::set_trace(TRACE_CALL);

#12/5/03: <sjburges@gimp.org>
# s/gimp_convert/gimp_image_convert/

sub my_code {
	my ($image, $drawable, $rad_tog, $pattern, $txt_col) = @_;
	Context->push();
	$drawable->has_alpha or die __"You can't run this script without an ALPHA CHANNEL!!";
	my $test = 0;
	$test = $drawable->type_with_alpha;
	if ($test == 5) {
		die __"You can't run this script with an INDEXED image!!";
	} elsif ($test == 3) {
		gimp_image_convert_rgb ($image);
	}
	my $img = gimp_image_new (100, 100, RGB_IMAGE);
	$drawable->get_image->selection_all;
	$drawable->edit_copy;
	gimp_selection_none ($image);
	my $layer;
	$layer=$img->layer_new($drawable->width,$drawable->height,$image->layertype(1), __"Text", 100, NORMAL_MODE);
	$layer->drawable_fill(TRANSPARENT_FILL);
	$img->insert_layer($layer,0,0);
	$layer->edit_paste(0)->floating_sel_anchor;
	$img->resize($drawable->width,$drawable->height, 0, 0);
	gimp_image_select_item($img, CHANNEL_OP_REPLACE, $layer);
	gimp_selection_invert ($img);
	Context->set_background ([255, 255, 255]);
	gimp_edit_fill ($layer, BACKGROUND_FILL);
	gimp_selection_none ($img);
	gimp_invert ($layer);
	plug_in_gauss_rle ($layer, 2.0, 1, 1);
	my $bump_lay;
	$bump_lay = $img->layer_new($img->width,$img->height, RGBA_IMAGE, __"Bumpmap", 100, NORMAL_MODE);
	$bump_lay->drawable_fill(BACKGROUND_FILL);
	$img->insert_layer($bump_lay,0,0);
	if ($rad_tog == 1) {
		Context->set_pattern ($pattern);
		gimp_edit_bucket_fill ($bump_lay, PATTERN_BUCKET_FILL, NORMAL_MODE, 100, 0, 0, 0, 0);
	} else {
		Context->set_background ($txt_col);
		gimp_edit_fill ($bump_lay, BACKGROUND_FILL);
	}
	plug_in_bump_map ($img, $bump_lay, $layer, 110.0, 45.0, 4, 0, 0, 0, 0, 1, 0, 0);
	$pattern_mask = gimp_layer_create_mask ($bump_lay, ADD_ALPHA_MASK);
	$bump_lay->add_mask($pattern_mask);
	gimp_selection_all ($img);
	gimp_edit_copy ($layer);
	$float = gimp_edit_paste ($pattern_mask, 0);
	gimp_floating_sel_anchor ($float);
	gimp_levels ($pattern_mask, 0, 0, 77, 0.91, 0, 255);
	$bump_lay->remove_mask (MASK_APPLY);
	gimp_invert ($layer);
	gimp_image_flatten ($img);
	gimp_image_convert_indexed ($img, 0, MAKE_PALETTE, 256, 0, 0, "");
	my $new = gimp_image_get_active_drawable ($img);
	gimp_layer_add_alpha ($new);
	gimp_image_select_color ($img, CHANNEL_OP_ADD, $new, [255, 255, 255]);
	gimp_edit_clear ($new);
	gimp_selection_none ($img);
	return ($img);
}
$help=<<EOF.$help;
This script aims to produce a transparent logo in an indexed image
which is ready to be saved in .gif format. If you need a transparent
image containing a logo for your web page, just apply this script over
a drawable with an alpha channel in RGB or GRAY mode.

You can choose between colour and pattern fill of your text.

As an input, you need to have an image that has an alpha channel, and isn't 100% opaque - its really designed to work with a text layer.  It will then make a "logo" out of your non-white sections of the image and index it.  The original image is untouched.

EOF

register "make_trans_logos",
	 "A script to get transparent beveled logos",
	 "$help",
	 "Michele Gherlone <mikem\@enet.it>",
	 "(c) 2000 M. Gherlone",
	 "20000123",
	 N_"<Image>/Filters/Web/Transparent Logo...",
	 "*",
	 [
	   [PF_RADIO	, 'use_a_colour_or_a_pattern_for_text', "The user's choice", 0, [Colour => 0, Pattern => 1]],
	   [PF_PATTERN	, 'choose_a_pattern', "Choose the text Pattern", "Wood #1"],
	   [PF_COLOUR	, 'choose_a_colour',  "Choose the text Color", [69, 88, 211]],
	 ],
	 \&my_code;
exit main;

=head1 LICENSE

Copyright Michele Gherlone.
Distributed under unknown licensing terms.

=cut
