#!/usr/bin/perl 

# <sjburges@gimp.org>
# Generate dots within a selection. 

use Gimp qw(:auto __ N_);
use Gimp::Fu;
use Gimp::Util;

# Gimp::set_trace(TRACE_ALL);

register "dots", 
         "Dots", 
         "Create evenly spaced dots on a layer, within a selection.",
         "Seth Burgess", 
         "Seth Burgess <sjburges\@gimp.org>", 
         "2003-09-20",
         N_"<Image>/Filters/Render/Pattern/Dots...", 
         "RGB*, GRAY*", 
         [ 
           [PF_SPINNER, "size", "Diameter of dots", 4, [1,255,1]], 
	   [PF_COLOR, "dotcolor", "Color of the dots", [0,0,255]],
	   [PF_SLIDER, "opacity", "Opacity of dots", 100, [0,100,1]],
           [PF_SPINNER, "xspacing", "Spacing of dots in X dimension", 16, [1,255,1]], 
           [PF_SPINNER, "yspacing", "Spacing of dots in Y dimension", 16, [1,255,1]], 
           [PF_SPINNER, "xoffset", "Offset of dots in X dimension", 0, [0,255,1]], 
           [PF_SPINNER, "yoffset", "Offset of dots in y dimension", 0, [0,255,1]], 
            ],
         [],
         ['gimp-1.3'],
         sub {
    my($img,$layer,$size,$dotcolor,$opacity,$xspacing,$yspacing,$xoffset,$yoffset) =@_;
    my $has_noselection;
    $layer->is_layer || die "A layer is required for this plugin";
     
    $yoffset = $yoffset % $yspacing;
    $xoffset = $xoffset % $xspacing;

    $img->undo_group_start;  

# Get/save current selection info
    @bounds = $img->selection_bounds;
    if (!$bounds[0])
      {
         $img->selection_all;
	 $has_noselection=1;
      }
    $selchannel = $img->selection_save;

# Generate selection mask of dots on entire image  
    $img->selection_none;
    for ($x=$xoffset-$xspacing;
         $x<$img->width+$size+$xspacing;
	 $x+=$xspacing)
      {
         for ($y=$yoffset-$yspacing;
	      $y<$img->height+$size+$yspacing;
	      $y+=$yspacing)
	   {
	     $img->ellipse_select($x-0.5*$size,$y-0.5*$size,
				  $size,$size,CHANNEL_OP_ADD,1,0,0.0);
           }
      }
   
# Set opacity of dots via selection mask 
    Context->push();

    $opc = gimp_channel_new($img,$img->width,$img->height,"OPC", 50, [0,0,0]);
    $img->add_channel($opc,0);
    Context->set_foreground([($opacity/100.0)x3]);
    $opc->fill(FOREGROUND_FILL);
    $opc->selection_combine(CHANNEL_OP_INTERSECT);

# And mask off with original selection 
    $selchannel->selection_combine(CHANNEL_OP_INTERSECT);

# Make the dots
    Context->set_foreground($dotcolor);
    $layer->edit_fill(FOREGROUND_FILL);
   
# Cleanup to state before plugin was called
    if ($has_noselection)
      {
        $img->selection_none;
      }
    else
      {
        $selchannel->selection_combine(CHANNEL_OP_REPLACE);
      }	 

    $img->remove_channel($selchannel);
    $img->remove_channel($opc);

    Context->pop();
    
    $img->undo_group_end;
    $layer->set_active_layer;

    return();
};
exit main;

=head1 LICENSE

Copyright Seth Burgess.  
Distrubuted under the same terms as Gimp-Perl.

=cut

